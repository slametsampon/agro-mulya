---
title: MQTT - Message Queuing Telemetry Transport
date: '2023-09-18'
tags: ['mqtt', 'kontrol', 'iot', 'protokol']
draft: false
summary: MQTT (Message Queuing Telemetry Transport) adalah protokol komunikasi ringan yang digunakan untuk mengirimkan data antar perangkat atau aplikasi dalam jaringan yang memiliki bandwidth terbatas atau kondisi koneksi yang tidak stabil.
images: []
---

- [Karakteristik utama dari MQTT:](#karakteristik-utama-dari-mqtt)
- [Apa itu topic dalam MQTT](#apa-itu-topic-dalam-mqtt)
- [Identifikasi topic dalam MQTT](#identifikasi-topic-dalam-mqtt)
- [Mekanisme pengiriman pesan dalam MQTT](#mekanisme-pengiriman-pesan-dalam-mqtt)
- [Broker dalam MQTT](#broker-dalam-mqtt)
- [Client dalam MQTT](#client-dalam-mqtt)
- [Publisher dalam MQTT](#publisher-dalam-mqtt)
- [Aplikasi](#aplikasi)
- [Menghubungkan ESP32 dengan broker MQTT](#menghubungkan-esp32-dengan-broker-mqtt)
  - [1. Instalasi Library MQTT pada Arduino IDE](#1-instalasi-library-mqtt-pada-arduino-ide)
  - [2. Tentukan Parameter Koneksi](#2-tentukan-parameter-koneksi)
  - [3. Inisialisasi Koneksi WiFi dan MQTT](#3-inisialisasi-koneksi-wifi-dan-mqtt)
  - [4. Fungsi Koneksi ke Broker MQTT](#4-fungsi-koneksi-ke-broker-mqtt)
  - [5. Fungsi Callback](#5-fungsi-callback)
  - [6. Fungsi Loop](#6-fungsi-loop)
- [Mengirim data dari ESP32 ke broker MQTT](#mengirim-data-dari-esp32-ke-broker-mqtt)
- [Menerima pesan dari broker MQTT dan mengolahnya di ESP32](#menerima-pesan-dari-broker-mqtt-dan-mengolahnya-di-esp32)
- [QoS (Quality of Service) 0, 1, dan 2 dalam mqtt](#qos-quality-of-service-0-1-dan-2-dalam-mqtt)
- [Menjaga koneksi MQTT tetap stabil pada ESP32](#menjaga-koneksi-mqtt-tetap-stabil-pada-esp32)
- [Pengamanan komunikasi MQTT antara ESP32 dan broker](#pengamanan-komunikasi-mqtt-antara-esp32-dan-broker)
- [Debugging ketika ada masalah dalam komunikasi MQTT dengan ESP32](#debugging-ketika-ada-masalah-dalam-komunikasi-mqtt-dengan-esp32)
- [Library MQTT yang direkomendasikan untuk digunakan dengan ESP32](#library-mqtt-yang-direkomendasikan-untuk-digunakan-dengan-esp32)
- [Implementasi autentikasi dengan username dan password saat terhubung ke broker MQTT pada ESP32](#implementasi-autentikasi-dengan-username-dan-password-saat-terhubung-ke-broker-mqtt-pada-esp32)
- [Implementasi Last Will and Testament (LWT) dalam MQTT, dan bagaimana mengonfiguraskannya di ESP32](#implementasi-last-will-and-testament-lwt-dalam-mqtt-dan-bagaimana-mengonfiguraskannya-di-esp32)
  - [Hak cipta^1. Artikel ini berdasar ChatGpt \& penulis tidak menjamin seluruh akurasi isinya](#hak-cipta1-artikel-ini-berdasar-chatgpt--penulis-tidak-menjamin-seluruh-akurasi-isinya)

MQTT (Message Queuing Telemetry Transport) adalah protokol komunikasi ringan yang digunakan untuk mengirimkan data antar perangkat atau aplikasi dalam jaringan yang memiliki bandwidth terbatas atau kondisi koneksi yang tidak stabil. MQTT dikembangkan oleh IBM pada tahun 1999 dan telah menjadi salah satu protokol yang populer dalam Internet of Things (IoT) dan aplikasi M2M (Machine-to-Machine) karena efisiensinya dalam penggunaan sumber daya.

![MQTT](/static/images/kontrol/mqtt.png)

## Karakteristik utama dari MQTT:

1. Publish-Subscribe Model: MQTT menggunakan model komunikasi publish-subscribe di mana perangkat atau aplikasi dapat berperan sebagai penerbit (publisher) yang mengirimkan pesan atau pelanggan (subscriber) yang menerima pesan. Ini memungkinkan komunikasi antar perangkat yang terhubung dalam jaringan.

2. Topik (Topic): Pesan dalam MQTT dikirimkan ke topik tertentu. Pelanggan dapat berlangganan ke topik-topik tertentu untuk menerima pesan yang relevan dengan topik tersebut.

3. QoS (Quality of Service): MQTT mendukung tiga tingkat QoS yang berbeda untuk mengontrol seberapa andal pengiriman pesan:

   - QoS 0 (At most once): Pesan dikirimkan sekali tanpa konfirmasi atau penyimpanan pesan.
   - QoS 1 (At least once): Pesan dikirimkan dengan konfirmasi pengiriman sekurangnya satu kali.
   - QoS 2 (Exactly once): Pesan dikirimkan dengan konfirmasi pengiriman pasti satu kali.

4. Retained Messages: MQTT mendukung pesan yang dikenal sebagai "retained messages" yang disimpan oleh broker dan dikirimkan ke pelanggan baru yang berlangganan ke topik yang sesuai.

5. Last Will and Testament (LWT): MQTT memungkinkan pengaturan pesan "last will" yang akan dikirimkan oleh broker kepada pelanggan jika pelanggan tersebut terputus secara tiba-tiba.

6. Ringan dan Efisien: MQTT dirancang untuk memiliki overhead komunikasi yang rendah dan membutuhkan sedikit sumber daya, sehingga cocok untuk perangkat dengan keterbatasan sumber daya seperti sensor IoT.

7. Broker-Based: MQTT menggunakan broker sebagai perantara untuk mengatur distribusi pesan antara penerbit dan pelanggan. Broker bertanggung jawab untuk mengarahkan pesan ke pelanggan yang berlangganan topik yang relevan.

Dengan karakteristik-karakteristik ini, MQTT telah menjadi salah satu protokol komunikasi yang populer untuk implementasi IoT dan aplikasi M2M, terutama ketika diperlukan komunikasi yang andal, efisien, dan skalabel di lingkungan yang memiliki banyak perangkat yang terhubung.

![MQTT-Topic](/static/images/kontrol/mqtt-topic1.jpg)

## Apa itu topic dalam MQTT

Dalam protokol MQTT (Message Queuing Telemetry Transport), "topic" (topik) adalah mekanisme penting yang digunakan untuk mengorganisasi dan mengarahkan aliran pesan antara penerbit (publisher) dan pelanggan (subscriber). Topik digunakan untuk menentukan konteks atau subjek dari sebuah pesan yang akan dikirimkan atau diterima melalui broker MQTT. Berikut beberapa poin penting tentang topik dalam MQTT:

1. **Identifikasi Pesan**: Topik digunakan untuk mengidentifikasi pesan dan memberikan informasi tentang isi pesan. Misalnya, jika Anda menggunakan MQTT untuk mengirim data suhu dari sensor, Anda dapat menggunakan topik seperti "suhu/ruang1" untuk mengidentifikasi pesan yang berisi data suhu dari ruangan tertentu.

2. **Hierarchy**: Topik dalam MQTT dapat membentuk hierarki yang terstruktur. Topik dapat memiliki struktur seperti "ruang/lokasi/sensor" untuk menggambarkan lokasi fisik atau jenis data yang dikirimkan. Ini memungkinkan Anda untuk mengorganisasi pesan dengan lebih baik.

3. **Wildcard Subscriptions**: MQTT mendukung dua jenis wildcard untuk berlangganan pesan, yaitu wildcard "#" (hash) dan "+" (plus). "#" digunakan untuk berlangganan ke semua subtopik di bawah topik yang sama, sedangkan "+" digunakan untuk berlangganan ke satu level subtopik tertentu. Misalnya, jika Anda berlangganan ke "suhu/#", Anda akan menerima semua pesan di bawah topik "suhu," sedangkan jika Anda berlangganan ke "suhu/+/sensor1," Anda akan menerima pesan hanya dari sensor tertentu di bawah topik "suhu."

4. **Publishing ke Topik**: Ketika seorang penerbit ingin mengirimkan pesan, ia harus menentukan topik yang sesuai dengan pesan tersebut. Pesan akan dikirimkan ke broker MQTT dengan topik yang ditentukan, dan pelanggan yang berlangganan ke topik yang sama akan menerima pesan tersebut.

5. **Topik Bersifat Case-Sensitive**: Dalam MQTT, topik bersifat case-sensitive, artinya "suhu" dan "Suhu" dianggap sebagai topik yang berbeda. Pastikan untuk menggunakan konsistensi dalam penamaan topik untuk menghindari kebingungan.

6. **Retained Messages**: Topik juga berperan dalam "retained messages." Jika pesan yang dikirim memiliki opsi retained yang diaktifkan, maka pesan tersebut akan disimpan oleh broker dengan topik yang sesuai, dan pesan ini akan dikirimkan ke pelanggan yang berlangganan ke topik tersebut saat mereka terhubung ke broker.

Dengan menggunakan topik, MQTT memungkinkan Anda untuk mengorganisasi, mengarahkan, dan mengelompokkan pesan dengan cara yang terstruktur, memungkinkan komunikasi yang efisien dan efektif antara perangkat dan aplikasi dalam jaringan MQTT.

![MQTT-Topic](/static/images/kontrol/mqtt-topic.png)

## Identifikasi topic dalam MQTT

Dalam protokol MQTT (Message Queuing Telemetry Transport), identifikasi yang paling umum adalah penggunaan topik (topic) untuk pesan dan pengenal klien untuk klien MQTT yang terhubung. Di bawah ini, saya akan menjelaskan cara memberikan identifikasi menggunakan topik dan pengenal klien dalam MQTT:

1. **Identifikasi dengan Topik (Topic)**:

   - **Pengirim (Publisher)**: Ketika Anda ingin mengirim pesan menggunakan MQTT, Anda perlu menentukan topik untuk pesan tersebut. Topik ini digunakan untuk mengidentifikasi pesan dan memberikan konteks tentang apa yang akan dikomunikasikan. Contohnya, jika Anda ingin mengirim data suhu dari sebuah sensor, Anda dapat menentukan topik seperti "suhu/ruang1" untuk pesan tersebut.
   - **Penerima (Subscriber)**: Untuk menerima pesan, pelanggan (subscriber) juga harus menentukan topik yang ingin mereka langgani. Mereka akan menerima pesan yang sesuai dengan topik yang mereka berlangganan. Misalnya, jika pelanggan berlangganan ke topik "suhu/#", mereka akan menerima semua pesan yang memiliki topik yang dimulai dengan "suhu/."

2. **Identifikasi dengan Pengenal Klien (Client Identifier)**:
   - **Klien MQTT** yang terhubung ke broker MQTT harus memberikan pengenal klien (client identifier) yang unik. Pengenal klien ini digunakan oleh broker untuk mengidentifikasi klien yang berbeda. Setiap klien yang terhubung ke broker harus memiliki pengenal klien yang berbeda.
   - Pengenal klien biasanya diberikan oleh perangkat atau aplikasi yang terhubung ke broker MQTT. Ini adalah cara bagi broker untuk melacak klien dan mengirim pesan kepada klien yang tepat.
   - Pengenal klien tidak terlihat oleh penerbit atau pelanggan lain dalam jaringan MQTT. Ini adalah pengenal internal yang digunakan oleh broker untuk manajemen koneksi.

Dengan menggunakan topik dan pengenal klien, MQTT memungkinkan identifikasi yang fleksibel dan kontekstual untuk pesan dan klien yang terhubung. Topik digunakan untuk mengidentifikasi pesan dan memberikan konteks, sedangkan pengenal klien digunakan untuk mengidentifikasi klien MQTT yang berbeda dalam jaringan. Kombinasi dari keduanya memungkinkan sistem MQTT untuk mengelola dan mengarahkan pesan dengan efisien antara berbagai perangkat dan aplikasi yang terhubung.

![MQTT-Topic](/static/images/kontrol/mqtt-topic2.png)

## Mekanisme pengiriman pesan dalam MQTT

Protokol MQTT (Message Queuing Telemetry Transport) memiliki mekanisme pengiriman pesan yang terstruktur dan andal. Berikut adalah langkah-langkah umum dalam mekanisme pengiriman pesan dengan MQTT:

1. **Penerbit (Publisher) Mengirim Pesan**:

   - Langkah pertama adalah penerbit (publisher) yang ingin mengirimkan pesan. Penerbit menentukan pesan yang ingin dikirimkan dan topik (topic) yang sesuai dengan pesan tersebut.

2. **Penerbit Terhubung ke Broker MQTT**:

   - Penerbit harus terhubung ke broker MQTT sebelum dapat mengirimkan pesan. Ini melibatkan proses autentikasi dan koneksi ke broker MQTT yang berjalan di server atau host yang ditentukan.

3. **Penerbit Menerbitkan Pesan ke Broker**:

   - Setelah terhubung ke broker, penerbit menerbitkan pesan ke broker dengan menentukan topik yang sesuai dengan pesan tersebut. Penerbit juga dapat menentukan tingkat Quality of Service (QoS) yang sesuai dengan kebutuhan.

4. **Broker Menyimpan Pesan**:

   - Setelah menerima pesan dari penerbit, broker MQTT menyimpan pesan tersebut dan memutuskan bagaimana pesan akan diteruskan ke pelanggan (subscriber) yang berlangganan topik yang sama.

5. **Pelanggan Berlangganan ke Topik**:

   - Pelanggan MQTT yang ingin menerima pesan tertentu harus berlangganan ke topik yang sesuai dengan pesan tersebut. Pelanggan dapat berlangganan ke topik dengan berbagai tingkat QoS.

6. **Broker Mengirim Pesan ke Pelanggan**:

   - Setiap kali ada pesan yang sesuai dengan topik yang telah di langganan oleh pelanggan, broker akan mengirimkan pesan tersebut ke pelanggan tersebut. Tingkat QoS yang digunakan akan memengaruhi seberapa andal pengiriman pesan ini.

7. **Konfirmasi Pengiriman (Opsional)**:

   - Bergantung pada tingkat QoS yang digunakan, ada tahap konfirmasi pengiriman yang mungkin terjadi.
     - QoS 0 (At most once): Pesan dikirim sekali tanpa konfirmasi. Pengiriman pesan tidak dijamin.
     - QoS 1 (At least once): Broker akan mengirim pesan sekurangnya satu kali, dan penerima akan mengirimkan konfirmasi penerimaan. Penerbit dapat mengirim ulang pesan jika tidak menerima konfirmasi.
     - QoS 2 (Exactly once): Pesan akan dikirimkan dengan konfirmasi pengiriman pasti sekali. Ini adalah tingkat QoS yang paling andal, tetapi juga memerlukan overhead tambahan.

8. **Pelanggan Menerima Pesan**:

   - Pelanggan akan menerima pesan yang telah dikirim oleh broker dan dapat mengolah atau menanggapi pesan tersebut sesuai kebutuhan.

9. **Pelanggan Terputus (Opsional)**:

   - Pelanggan dapat terputus dari broker setelah selesai menerima pesan atau sesuai dengan kebutuhan.

10. **Pemeliharaan Koneksi (Opsional)**:
    - Broker dan klien MQTT dapat melakukan pemeliharaan koneksi agar tetap aktif atau mengatasi kehilangan koneksi jika diperlukan.

Mekanisme pengiriman pesan MQTT sangat fleksibel dan dapat disesuaikan dengan kebutuhan aplikasi Anda. Anda dapat mengatur tingkat QoS yang sesuai, mengelola pelanggan dan penerbit, serta mengatur broker MQTT untuk mengelola pesan dalam jaringan MQTT Anda.

![MQTT-Broker](/static/images/kontrol/mqtt-broker.jpg)

## Broker dalam MQTT

Dalam protokol MQTT (Message Queuing Telemetry Transport), "broker" adalah komponen inti atau server yang bertindak sebagai perantara (middleware) dalam sistem komunikasi MQTT. Broker MQTT adalah entitas yang mengatur dan mengelola aliran pesan antara penerbit (publisher) dan pelanggan (subscriber) dalam jaringan MQTT. Fungsi utama broker MQTT adalah mengumpulkan pesan dari penerbit dan meneruskannya kepada pelanggan yang berlangganan topik yang sesuai.

Berikut adalah beberapa karakteristik utama dari broker MQTT:

1. **Menerima Pesan**: Broker MQTT menerima pesan yang dikirim oleh penerbit. Pesan ini dapat berisi data sensor, perintah untuk perangkat, atau informasi lain yang perlu dikomunikasikan dalam jaringan MQTT.

2. **Mengatur Pesan**: Broker menyimpan pesan yang diterimanya dan mengatur cara pengiriman pesan ke pelanggan yang berlangganan topik yang sesuai. Ini mencakup penentuan pelanggan mana yang harus menerima pesan dan tingkat Quality of Service (QoS) yang digunakan.

3. **Distribusi Pesan**: Berdasarkan topik pesan dan langganan pelanggan, broker mendistribusikan pesan kepada pelanggan yang berlangganan. Ini termasuk penggunaan wildcard dalam topik yang memungkinkan pelanggan berlangganan ke berbagai subtopik.

4. **Manajemen Koneksi**: Broker mengelola koneksi dari berbagai klien MQTT (penerbit dan pelanggan). Ini termasuk autentikasi klien, pemeliharaan koneksi, dan penanganan klien yang baru terhubung atau terputus.

5. **Retained Messages**: Broker dapat menyimpan pesan yang memiliki opsi retained, yang berarti pesan tersebut akan disimpan oleh broker dan dikirimkan kepada pelanggan yang baru berlangganan ke topik yang sesuai.

6. **Penerbitan Pesan Konfirmasi**: Jika diperlukan, broker MQTT dapat memberikan konfirmasi (acknowledgment) kepada penerbit pesan, terutama pada tingkat QoS yang lebih tinggi, seperti QoS 1 dan QoS 2. Ini memastikan pesan berhasil disampaikan.

7. **Security**: Broker juga dapat mengimplementasikan langkah-langkah keamanan, seperti autentikasi, otorisasi, dan enkripsi, untuk melindungi komunikasi dalam jaringan MQTT.

Beberapa broker MQTT yang populer termasuk Mosquitto, Eclipse Mosquitto, HiveMQ, dan banyak lagi. Pilihan broker akan tergantung pada kebutuhan proyek Anda, seperti tingkat keandalan, skala, dan fitur keamanan yang diperlukan. Dengan adanya broker MQTT, perangkat dan aplikasi dalam jaringan MQTT dapat berkomunikasi secara efisien dan terstruktur.

![MQTT-Broker](/static/images/kontrol/mqtt-broker1.jpg)

## Client dalam MQTT

Dalam protokol MQTT (Message Queuing Telemetry Transport), "klien" (client) merujuk kepada perangkat atau aplikasi yang terhubung ke broker MQTT untuk berpartisipasi dalam pertukaran pesan dalam jaringan MQTT. Klien dapat berperan sebagai penerbit (publisher), pelanggan (subscriber), atau bahkan keduanya, tergantung pada peran yang diambilnya dalam komunikasi MQTT.

Berikut adalah peran utama yang dapat dimainkan oleh klien dalam MQTT:

1. **Penerbit (Publisher)**:

   - Sebagai penerbit, klien menghasilkan dan mengirimkan pesan ke broker MQTT. Penerbit menentukan topik (topic) yang sesuai dengan pesan tersebut.
   - Penerbit berinteraksi dengan broker untuk mengirim pesan ke topik tertentu. Pesan yang dikirim oleh penerbit akan tersedia untuk pelanggan yang berlangganan topik yang sama.

2. **Pelanggan (Subscriber)**:

   - Sebagai pelanggan, klien berlangganan ke topik-topik yang menarik bagi mereka. Ketika pelanggan berlangganan ke suatu topik, mereka akan menerima pesan yang dikirim ke topik tersebut oleh penerbit lain.
   - Pelanggan dapat berlangganan ke topik tunggal atau menggunakan wildcard seperti "#" atau "+" untuk berlangganan ke berbagai topik yang sesuai dengan pola tertentu.

3. **Pengenal Klien (Client Identifier)**:

   - Setiap klien MQTT harus memiliki pengenal klien (client identifier) yang unik ketika mereka terhubung ke broker. Pengenal klien ini digunakan oleh broker untuk mengidentifikasi dan membedakan antara klien yang berbeda yang terhubung.
   - Pengenal klien biasanya disediakan oleh perangkat atau aplikasi yang terhubung ke broker MQTT. Ini adalah cara broker mengenali dan melacak klien-klien dalam jaringan MQTT.

4. **Tingkat Quality of Service (QoS)**:
   - Klien juga menentukan tingkat Quality of Service (QoS) yang akan digunakan saat berkomunikasi dengan broker MQTT. QoS mengatur seberapa andal pengiriman pesan dan proses konfirmasi yang diperlukan.

Klien MQTT dapat berupa perangkat fisik seperti sensor IoT, perangkat mikrokontroler (seperti ESP32), atau aplikasi perangkat lunak yang terhubung ke broker MQTT. Mereka berperan penting dalam menjalankan komunikasi dalam jaringan MQTT, memungkinkan perangkat dan aplikasi untuk saling berkomunikasi dan berbagi informasi secara efisien. Setiap klien harus mematuhi protokol MQTT dan bekerja sama dengan broker untuk mengatur pengiriman pesan dan penerimaan pesan sesuai dengan topik dan tingkat QoS yang sesuai.

![MQTT-Publisher](/static/images/kontrol/mqtt-publisher.png)

## Publisher dalam MQTT

Dalam protokol MQTT (Message Queuing Telemetry Transport), "publisher" adalah klien MQTT yang berperan sebagai pengirim pesan. Publisher menghasilkan dan mengirimkan pesan ke broker MQTT, yang kemudian akan mendistribusikannya ke pelanggan (subscribers) yang berlangganan topik yang sesuai.

Berikut adalah beberapa informasi lebih lanjut tentang publisher dalam MQTT:

1. **Pengiriman Pesan**: Publisher bertanggung jawab untuk menghasilkan pesan dan mengirimkannya ke broker MQTT. Pesan tersebut dapat berisi data, perintah, atau informasi lain yang perlu disebarkan kepada pelanggan atau aplikasi lain yang berlangganan topik yang sesuai.

2. **Topik (Topic)**: Saat seorang publisher mengirim pesan, ia harus menentukan topik yang sesuai dengan pesan tersebut. Topik adalah cara utama untuk mengidentifikasi konteks atau subjek dari pesan. Misalnya, jika publisher ingin mengirim data suhu dari sensor, ia dapat menggunakan topik seperti "suhu/ruang1" untuk mengidentifikasi pesan tersebut.

3. **Quality of Service (QoS)**: Publisher dapat menentukan tingkat Quality of Service (QoS) yang akan digunakan saat mengirim pesan. QoS mengatur seberapa andal pengiriman pesan dan proses konfirmasi yang diperlukan. Terdapat tiga tingkat QoS yang berbeda dalam MQTT: QoS 0 (At most once), QoS 1 (At least once), dan QoS 2 (Exactly once).

4. **Identifikasi Klien**: Publisher harus terhubung ke broker MQTT dan memiliki pengenal klien (client identifier) yang unik. Pengenal klien ini digunakan oleh broker untuk mengidentifikasi dan membedakan publisher dari klien lain yang terhubung.

5. **Broker Intermediary**: Setelah menerima pesan dari publisher, broker MQTT bertanggung jawab untuk menyimpan pesan tersebut dan mendistribusikannya ke pelanggan yang berlangganan topik yang sesuai. Broker juga dapat mengirimkan konfirmasi pengiriman (acknowledgment) kepada publisher, terutama jika publisher menggunakan tingkat QoS yang lebih tinggi.

6. **Penerbitan Pesan**: Proses pengiriman pesan dari publisher ke broker disebut "penerbitan" (publishing). Ini adalah langkah penting dalam komunikasi MQTT, yang memungkinkan berbagai perangkat dan aplikasi untuk berbagi informasi dalam jaringan MQTT.

Publisher sering digunakan dalam skenario IoT (Internet of Things) di mana perangkat seperti sensor menghasilkan data yang perlu disebarkan atau dikirimkan ke perangkat atau aplikasi lain dalam jaringan. Dengan menggunakan publisher, perangkat dapat berkomunikasi dengan broker MQTT dan menyebarkan informasi kepada pelanggan atau pihak yang berkepentingan lainnya secara efisien.

![MQTT-Aplikasi](/static/images/kontrol/mqtt-aplikasi.jpg)

## Aplikasi

MQTT (Message Queuing Telemetry Transport) adalah protokol yang sangat berguna dalam menghubungkan ESP32 (sistem mikrokontroler) ke jaringan dan perangkat lain, terutama dalam konteks Internet of Things (IoT). Dengan menggunakan MQTT pada ESP32, Anda dapat mengirim dan menerima data antara ESP32 dan broker MQTT, yang kemudian dapat digunakan untuk mengintegrasikan ESP32 dengan aplikasi lain atau perangkat IoT lainnya. Berikut adalah beberapa aplikasi umum MQTT dalam ESP32:

1. **Monitoring Sensor**: ESP32 sering digunakan untuk mengambil data dari berbagai jenis sensor seperti suhu, kelembaban, tekanan, atau sensor lainnya. Data dari sensor tersebut dapat dikirim melalui MQTT ke broker, dan aplikasi lain dapat berlangganan ke data tersebut untuk pemantauan atau pengambilan keputusan.

2. **Kontrol Perangkat**: Anda dapat menggunakan MQTT untuk mengontrol perangkat fisik yang terhubung ke ESP32, seperti lampu, motor, atau perangkat lainnya. Dengan menerbitkan pesan MQTT, Anda dapat mengirim perintah kepada ESP32 untuk mengendalikan perangkat tersebut.

3. **Integrasi dengan Cloud**: Anda dapat menghubungkan ESP32 dengan layanan cloud seperti AWS IoT, Google Cloud IoT Core, atau Azure IoT Hub menggunakan MQTT. Ini memungkinkan Anda untuk menyimpan, menganalisis, atau memproses data dari ESP32 secara lebih terpusat di cloud.

4. **Over-the-Air (OTA) Updates**: MQTT dapat digunakan untuk mengirimkan pembaruan perangkat lunak (firmware) ke ESP32 secara nirkabel. Anda dapat mengatur ESP32 untuk berlangganan ke topik pembaruan dan menerima pembaruan firmware saat tersedia.

5. **Sistem Keamanan**: Anda dapat menggunakan MQTT untuk mengirimkan peringatan atau notifikasi ke perangkat ESP32 ketika terjadi kejadian yang perlu diawasi seperti intrusi, kebakaran, atau pengrusakan.

6. **Remote Monitoring dan Kontrol**: MQTT memungkinkan Anda untuk memantau dan mengendalikan ESP32 dari jarak jauh melalui broker MQTT. Ini berguna dalam skenario di mana Anda perlu mengakses perangkat ESP32 yang terletak di lokasi yang berjauhan.

Penting untuk dicatat bahwa untuk mengimplementasikan MQTT pada ESP32, Anda perlu menggunakan pustaka (library) MQTT yang sesuai, seperti PubSubClient atau Arduino MQTT Library, tergantung pada lingkungan pengembangan yang Anda gunakan. Anda juga perlu mengatur broker MQTT yang akan digunakan oleh ESP32 dan memastikan bahwa perangkat Anda memiliki koneksi internet yang stabil untuk berkomunikasi dengan broker tersebut.

Berikut beberapa contoh pertanyaan yang dapat diajukan terkait penggunaan ESP32 dengan protokol MQTT:

## Menghubungkan ESP32 dengan broker MQTT

Menghubungkan ESP32 dengan broker MQTT melibatkan beberapa langkah dasar. Berikut adalah langkah-langkah umumnya:

### 1. Instalasi Library MQTT pada Arduino IDE

Pertama, pastikan Anda telah menginstal library MQTT di Arduino IDE. Anda dapat mencari dan menginstalnya melalui "Library Manager" di Arduino IDE. Library umum yang digunakan adalah "PubSubClient".

### 2. Tentukan Parameter Koneksi

Tentukan parameter koneksi ke broker MQTT, termasuk alamat IP atau nama domain broker, port, serta ID klien MQTT, nama pengguna, dan kata sandi jika dibutuhkan.

```cpp
const char* mqtt_server = "alamat_broker_mqtt";
const int mqtt_port = 1883; // Port default MQTT
const char* mqtt_user = "nama_pengguna"; // Kosongkan jika tidak diperlukan
const char* mqtt_password = "kata_sandi"; // Kosongkan jika tidak diperlukan
const char* clientID = "ESP32Client";
```

### 3. Inisialisasi Koneksi WiFi dan MQTT

Hubungkan ESP32 ke jaringan WiFi dan inisialisasi koneksi ke broker MQTT dalam fungsi setup():

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

WiFiClient espClient;
PubSubClient client(espClient);

void setup_wifi() {
  // Koneksi ke WiFi
  WiFi.begin("nama_jaringan_wifi", "kata_sandi_wifi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Gagal terhubung ke WiFi.. coba lagi");
  }
  Serial.println("Terhubung ke WiFi");

  // Koneksi ke broker MQTT
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);
}
```

Pastikan untuk mengganti "nama_jaringan_wifi" dan "kata_sandi_wifi" dengan kredensial WiFi Anda.

### 4. Fungsi Koneksi ke Broker MQTT

Tambahkan fungsi untuk menghubungkan ESP32 ke broker MQTT dalam setup():

```cpp
void reconnect() {
  while (!client.connected()) {
    Serial.print("Mencoba terhubung ke MQTT broker...");
    if (client.connect(clientID, mqtt_user, mqtt_password)) {
      Serial.println("Terhubung");
      client.subscribe("topik/subs/esp32"); // Topik untuk berlangganan
    } else {
      Serial.print("Gagal, rc=");
      Serial.print(client.state());
      Serial.println(" Coba lagi dalam 5 detik");
      delay(5000);
    }
  }
}
```

Fungsi ini akan mencoba terhubung ke broker MQTT dengan ID klien, nama pengguna, dan kata sandi yang telah ditentukan. Jika gagal, itu akan mencoba lagi setiap 5 detik.

### 5. Fungsi Callback

Tambahkan fungsi callback untuk menangani pesan yang diterima dari broker MQTT:

```cpp
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Pesan masuk [");
  Serial.print(topic);
  Serial.print("] ");
  for (int i = 0; i < length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();

  // Tambahkan logika untuk menanggapi pesan di sini
}
```

### 6. Fungsi Loop

Dalam fungsi loop(), panggil fungsi `reconnect()` dan `client.loop()` untuk menjaga koneksi ke broker MQTT aktif:

```cpp
void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // Tambahkan logika perangkat di sini
}
```

Dengan mengikuti langkah-langkah ini, ESP32 Anda akan terhubung ke broker MQTT dan siap untuk mengirim dan menerima pesan MQTT. Pastikan untuk menyesuaikan kode sesuai dengan kebutuhan aplikasi Anda.

## Mengirim data dari ESP32 ke broker MQTT

Untuk mengirim data dari ESP32 ke broker MQTT, Anda dapat mengikuti langkah-langkah berikut:

1. **Persiapkan Data yang Akan Dikirim**:
   Anda harus memiliki data yang ingin Anda kirim ke broker MQTT. Data ini bisa berupa suhu dari sensor, kelembaban udara, status perangkat, atau jenis data lainnya yang relevan dengan proyek Anda.

2. **Gunakan Fungsi `client.publish()`**:
   Dalam loop program Anda atau dalam logika yang sesuai, gunakan fungsi `client.publish()` dari library MQTT untuk mengirim data ke broker MQTT. Berikut adalah contoh penggunaannya:

```cpp
client.publish("topik/publish/esp32", "Data yang akan dikirim");
```

- `"topik/publish/esp32"` adalah topik MQTT yang akan Anda gunakan untuk mengirim data. Anda bisa mengganti topik ini sesuai dengan kebutuhan Anda.
- `"Data yang akan dikirim"` adalah pesan yang akan Anda kirim.

3. **Cek Koneksi MQTT**:
   Pastikan bahwa Anda telah memastikan koneksi ke broker MQTT dengan memanggil `client.connected()` sebelum mencoba mengirim data. Jika koneksi terputus, Anda perlu mencoba menghubungkan kembali sebelum mengirim data.

Contoh lengkap untuk mengirim data dari ESP32 ke broker MQTT mungkin terlihat seperti ini:

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

WiFiClient espClient;
PubSubClient client(espClient);

const char* mqtt_server = "alamat_broker_mqtt";
const int mqtt_port = 1883;
const char* mqtt_user = "nama_pengguna"; // Kosongkan jika tidak diperlukan
const char* mqtt_password = "kata_sandi"; // Kosongkan jika tidak diperlukan

void setup() {
  // Inisialisasi koneksi WiFi dan MQTT seperti sebelumnya
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // Mendapatkan data yang akan dikirim
  float suhu = bacaSuhuSensor(); // Contoh fungsi pembacaan suhu dari sensor

  // Mengirim data ke broker MQTT
  char buffer[10];
  snprintf(buffer, sizeof(buffer), "%.2f", suhu); // Konversi nilai float menjadi string
  client.publish("topik/suhu", buffer); // Mengirim data suhu
  delay(5000); // Menunda pengiriman selama 5 detik
}

void reconnect() {
  while (!client.connected()) {
    Serial.println("Mencoba terhubung ke MQTT broker...");
    if (client.connect("ESP32Client", mqtt_user, mqtt_password)) {
      Serial.println("Terhubung");
    } else {
      Serial.print("Gagal, rc=");
      Serial.print(client.state());
      Serial.println(" Coba lagi dalam 5 detik");
      delay(5000);
    }
  }
}

float bacaSuhuSensor() {
  // Logika untuk membaca suhu dari sensor
  // Implementasi sesuai dengan sensor yang Anda gunakan
}
```

Dalam contoh ini, ESP32 mengukur suhu (dalam contoh ini) dan mengirimkannya ke broker MQTT setiap 5 detik. Anda dapat mengganti data yang dikirim dan frekuensinya sesuai dengan kebutuhan aplikasi Anda.

## Menerima pesan dari broker MQTT dan mengolahnya di ESP32

Untuk menerima pesan dari broker MQTT dan mengolahnya di ESP32, Anda perlu mengikuti langkah-langkah berikut:

1. **Definisikan Fungsi Callback**: Anda perlu menentukan sebuah fungsi callback yang akan dipanggil setiap kali pesan diterima dari broker MQTT. Fungsi ini akan menerima pesan dan informasi tentang topiknya.

```cpp
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Pesan masuk [");
  Serial.print(topic);
  Serial.print("] ");
  for (int i = 0; i < length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();

  // Tambahkan logika untuk mengolah pesan di sini
}
```

2. **Daftarkan Fungsi Callback**: Di dalam fungsi `setup()`, daftarkan fungsi callback dengan menggunakan `client.setCallback(callback)`.

```cpp
void setup() {
  // Inisialisasi koneksi WiFi dan MQTT seperti sebelumnya

  // Daftarkan fungsi callback
  client.setCallback(callback);
}
```

3. **Menerapkan Logika Pengolahan Pesan**: Dalam fungsi callback, Anda dapat menerapkan logika untuk mengolah pesan yang diterima. Bergantung pada topik dan data yang diterima, Anda dapat melakukan tindakan tertentu.

Contoh lengkap:

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

WiFiClient espClient;
PubSubClient client(espClient);

const char* mqtt_server = "alamat_broker_mqtt";
const int mqtt_port = 1883;
const char* mqtt_user = "nama_pengguna"; // Kosongkan jika tidak diperlukan
const char* mqtt_password = "kata_sandi"; // Kosongkan jika tidak diperlukan

void setup() {
  // Inisialisasi koneksi WiFi dan MQTT seperti sebelumnya

  // Daftarkan fungsi callback
  client.setCallback(callback);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // Logika perangkat Anda di sini
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Pesan masuk [");
  Serial.print(topic);
  Serial.print("] ");
  for (int i = 0; i < length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();

  // Mengolah pesan yang diterima
  if (strcmp(topic, "topik/pesan/esp32") == 0) {
    // Logika khusus untuk topik tertentu
    // Contoh: Mengontrol perangkat berdasarkan pesan yang diterima
    if (payload[0] == '1') {
      // Melakukan tindakan jika pesan adalah "1"
    } else if (payload[0] == '0') {
      // Melakukan tindakan jika pesan adalah "0"
    }
  }
}

void reconnect() {
  while (!client.connected()) {
    Serial.println("Mencoba terhubung ke MQTT broker...");
    if (client.connect("ESP32Client", mqtt_user, mqtt_password)) {
      Serial.println("Terhubung");
      client.subscribe("topik/pesan/esp32"); // Topik untuk berlangganan
    } else {
      Serial.print("Gagal, rc=");
      Serial.print(client.state());
      Serial.println(" Coba lagi dalam 5 detik");
      delay(5000);
    }
  }
}
```

Dalam contoh di atas, fungsi `callback()` akan mengolah pesan yang diterima dari broker MQTT. Anda dapat menyesuaikan logika pengolahan pesan sesuai dengan kebutuhan aplikasi Anda. Pastikan untuk berlangganan topik yang sesuai dengan pesan yang Anda ingin terima dengan `client.subscribe()`.

## QoS (Quality of Service) 0, 1, dan 2 dalam mqtt

QoS (Quality of Service) dalam MQTT (Message Queuing Telemetry Transport) adalah parameter yang mengatur tingkat keandalan pengiriman pesan antara klien MQTT dan broker MQTT. Ada tiga tingkatan QoS yang berbeda: 0, 1, dan 2. Berikut adalah perbedaan utama antara mereka dan cara menggunakannya dengan ESP32:

1. **QoS 0 (At most once)**:

   - Pesan dikirim dengan cara best effort. Tidak ada konfirmasi atau retry.
   - Pesan dapat hilang jika broker atau klien tidak tersedia saat pengiriman.
   - Tidak ada jaminan bahwa pesan akan tiba atau diproses oleh penerima.
   - Biasanya digunakan untuk data yang bisa diabaikan atau jika pengiriman ulang tidak diperlukan.

   Penggunaan di ESP32:

   ```cpp
   client.publish("topik", "Pesan dengan QoS 0", 0);
   ```

2. **QoS 1 (At least once)**:

   - Pesan dikirim dengan jaminan pengiriman setidaknya satu kali.
   - Jika broker menerima pesan, itu akan mengirimkan konfirmasi penerimaan (PUBACK) ke pengirim.
   - Pengirim akan mencoba mengirim ulang pesan jika konfirmasi tidak diterima dalam waktu tertentu.
   - Mungkin ada duplikasi pesan jika konfirmasi diterima lebih dari sekali.

   Penggunaan di ESP32:

   ```cpp
   client.publish("topik", "Pesan dengan QoS 1", 1);
   ```

3. **QoS 2 (Exactly once)**:

   - Pesan dikirim dengan jaminan pengiriman tepat satu kali.
   - Ini adalah level QoS yang paling andal, tetapi juga yang paling mahal dari segi kinerja.
   - Menggunakan tiga pertukaran pesan (PUBLISH, PUBREC, dan PUBREL) untuk memastikan pengiriman yang tepat.

   Penggunaan di ESP32:

   ```cpp
   client.publish("topik", "Pesan dengan QoS 2", 2);
   ```

Untuk menggunakan QoS pada ESP32, Anda hanya perlu menentukan tingkat QoS saat memanggil `client.publish()` seperti yang ditunjukkan dalam contoh di atas. Anda juga perlu memastikan bahwa broker MQTT yang Anda gunakan mendukung tingkat QoS yang Anda pilih.

Penting untuk memilih tingkat QoS yang sesuai dengan kebutuhan aplikasi Anda. QoS 0 dapat digunakan jika pengiriman yang tepat tidak kritis, sedangkan QoS 1 atau QoS 2 lebih sesuai jika keandalan dan pengiriman yang tepat diperlukan. Namun, perlu diingat bahwa semakin tinggi tingkat QoS, semakin banyak overhead yang terkait dengan komunikasi.

## Menjaga koneksi MQTT tetap stabil pada ESP32

Menjaga koneksi MQTT tetap stabil pada ESP32, terutama saat jaringan WiFi tidak stabil, merupakan tugas penting dalam pengembangan aplikasi IoT yang andal. Di bawah ini adalah beberapa langkah yang dapat Anda lakukan untuk mengatasi masalah stabilitas koneksi MQTT pada ESP32:

1. **Rekoneksi Otomatis**:
   Implementasikan logika rekoneksi otomatis jika koneksi ke broker MQTT terputus. Anda dapat melakukannya dengan mengatur ulang koneksi dalam loop program Anda. Contoh fungsi `reconnect()` yang telah saya sebutkan dalam jawaban sebelumnya adalah salah satu contohnya.

2. **Backoff Exponential**:
   Gunakan strategi backoff eksponensial saat mencoba menghubungkan kembali ke broker MQTT. Ini berarti Anda harus menunggu waktu yang semakin lama antara setiap percobaan rekoneksi. Ini dapat membantu meringankan beban pada broker jika ada masalah jaringan yang sementara.

3. **Deteksi Status WiFi**:
   Periksa status koneksi WiFi menggunakan `WiFi.status()` dan rekonfigurasi koneksi WiFi jika diperlukan. Anda dapat melakukan ini sebelum mencoba menghubungkan kembali ke broker MQTT.

```cpp
if (WiFi.status() != WL_CONNECTED) {
  // Rekoneksikan ke WiFi jika terputus
  setup_wifi();
}
```

4. **Penanganan Exception**:
   Tambahkan penanganan exception pada kode Anda untuk menangani situasi yang tidak terduga yang dapat menyebabkan program berhenti atau koneksi terputus.

5. **Gunakan LWT (Last Will and Testament)**:
   Implementasikan fitur LWT dalam konfigurasi koneksi MQTT Anda. LWT memungkinkan broker untuk mengirim pesan jika klien terputus secara mendadak. Anda dapat mengonfigurasi pesan LWT untuk memberi tahu status klien saat terputus dan mengambil tindakan yang sesuai setelah menerima pesan LWT.

6. **Monitoring dan Logging**:
   Tambahkan pemantauan dan log ke dalam kode Anda untuk memantau perilaku koneksi MQTT. Dengan log yang tepat, Anda dapat dengan cepat mengidentifikasi masalah dan mengambil tindakan perbaikan.

7. **Optimalkan Kode**:
   Pastikan kode Anda efisien dan tidak membebani ESP32 terlalu banyak. Hal ini dapat mempengaruhi stabilitas dan kinerja koneksi MQTT.

8. **Perangkat Cadangan**:
   Pertimbangkan menggunakan perangkat cadangan atau redundansi jika koneksi MQTT sangat penting. Dengan menggunakan lebih dari satu ESP32 atau broker MQTT, Anda dapat meningkatkan keandalan sistem Anda.

9. **Uji Koneksi di Berbagai Skenario**:
   Selalu uji aplikasi Anda dalam berbagai kondisi jaringan untuk memastikan koneksi MQTT tetap stabil di bawah berbagai situasi, termasuk jaringan yang tidak stabil.

10. **Update Firmware dan Library**:
    Pastikan Anda menggunakan versi firmware ESP32 yang terbaru dan versi library MQTT yang terbaru. Pembaruan mungkin memperbaiki bug dan meningkatkan stabilitas.

Dengan menerapkan langkah-langkah di atas, Anda dapat meningkatkan stabilitas koneksi MQTT pada ESP32 bahkan dalam situasi jaringan yang tidak stabil. Tetap memonitor kinerja sistem Anda dan melakukan uji coba adalah praktik terbaik untuk memastikan keandalan koneksi MQTT.

## Pengamanan komunikasi MQTT antara ESP32 dan broker

Mengamankan komunikasi MQTT antara ESP32 dan broker sangat penting untuk melindungi data dan menjaga keamanan sistem Anda. Berikut adalah beberapa hal yang perlu Anda perhatikan untuk mengamankan komunikasi MQTT:

1. **Gunakan TLS/SSL**:
   Aktifkan enkripsi TLS/SSL untuk lalu lintas MQTT antara ESP32 dan broker. Ini akan mengenkripsi data yang dikirimkan melalui jaringan dan mencegah pihak ketiga mengintip atau memanipulasi pesan.

2. **Verifikasi Sertifikat**:
   Pastikan ESP32 dan broker saling memverifikasi sertifikat TLS/SSL satu sama lain untuk menghindari serangan man-in-the-middle. Ini memastikan bahwa koneksi Anda aman dan terhubung ke broker yang benar.

3. **Gunakan Kata Sandi Kuat**:
   Jika Anda mengaktifkan autentikasi MQTT dengan kata sandi, pastikan kata sandi yang digunakan kuat dan sulit ditebak. Jangan gunakan kata sandi default atau mudah ditebak.

4. **Implementasikan Autentikasi**:
   Aktifkan autentikasi MQTT dengan menggunakan nama pengguna dan kata sandi. Broker MQTT harus dikonfigurasi untuk memerlukan autentikasi sebelum klien dapat terhubung.

5. **Gunakan Topik Berdasarkan Hak Akses**:
   Gunakan ACL (Access Control List) atau hak akses pada broker MQTT untuk mengontrol akses ke topik. Hanya izinkan klien yang sah untuk mengirim dan menerima pesan dari topik tertentu.

6. **Batasan Koneksi**:
   Terapkan pembatasan pada jumlah koneksi yang dapat dibuat oleh klien dan batasan kuota untuk mencegah penyalahgunaan sumber daya dan serangan DoS (Denial of Service).

7. **Perbarui Perangkat Lunak**:
   Pastikan bahwa firmware ESP32 dan broker MQTT Anda diperbarui secara berkala untuk mengatasi kerentanan keamanan yang ditemukan dalam versi sebelumnya.

8. **Gunakan MQTT dengan Autentikasi Lainnya**:
   Selain penggunaan nama pengguna dan kata sandi, Anda juga dapat menggunakan mekanisme autentikasi lain seperti OAuth atau token JWT (JSON Web Token) untuk autentikasi.

9. **Firewall dan Segmentation**:
   Gunakan firewall dan segmentasi jaringan untuk membatasi akses ke broker MQTT. Jika mungkin, tempatkan broker dalam jaringan yang terisolasi dari jaringan publik.

10. **Monitoring Keamanan**:
    Pasang alat pemantauan keamanan untuk memantau aktivitas MQTT dan mendeteksi aktivitas yang mencurigakan atau serangan.

11. **Enkripsi Data End-to-End**:
    Jika memungkinkan, pertimbangkan untuk mengenkripsi data di tingkat aplikasi sehingga data tetap terenkripsi bahkan setelah tiba di broker MQTT. Ini akan memberikan lapisan keamanan tambahan.

12. **Batasi Hak Akses pada ESP32**:
    Pastikan ESP32 hanya memiliki akses ke sumber daya yang diperlukan untuk menjalankan aplikasi dan tidak memiliki hak akses yang tidak perlu.

Dengan mengimplementasikan langkah-langkah keamanan di atas, Anda dapat menjaga komunikasi MQTT antara ESP32 dan broker tetap aman dan terlindungi dari potensi ancaman keamanan. Keamanan adalah aspek penting dalam pengembangan aplikasi IoT yang harus diperhatikan dari awal.

## Debugging ketika ada masalah dalam komunikasi MQTT dengan ESP32

Mengatasi masalah debugging saat ada masalah dalam komunikasi MQTT antara ESP32 dan broker merupakan langkah penting dalam mengidentifikasi dan memperbaiki masalah. Berikut adalah beberapa langkah yang dapat Anda ikuti:

1. **Aktifkan Debugging**: Aktifkan debugging di ESP32 dengan menggunakan perintah `Serial.begin()` untuk mengirim pesan debug ke serial monitor. Ini akan membantu Anda melihat pesan debug yang dapat membantu mengidentifikasi masalah.

   ```cpp
   Serial.begin(115200); // Aktifkan debugging serial
   ```

2. **Tambahkan Pesan Debug**: Tambahkan pesan debug ke dalam kode Anda untuk melacak alur eksekusi program. Ini dapat membantu Anda menemukan di mana masalahnya terjadi.

   ```cpp
   Serial.println("Pesan debug di sini");
   ```

3. **Cek Status Koneksi**: Gunakan `WiFi.status()` dan `client.connected()` untuk memeriksa status koneksi WiFi dan MQTT pada ESP32. Pesan debug dapat membantu Anda memahami apakah masalah terletak pada koneksi.

4. **Periksa Logika Aplikasi**: Pastikan logika aplikasi Anda berfungsi dengan benar. Terkadang masalah dalam kode aplikasi bisa menjadi penyebab masalah dalam komunikasi MQTT.

5. **Log Pesan MQTT**: Log pesan MQTT yang dikirim dan diterima. Ini akan membantu Anda melihat apa yang dikirimkan dan diterima oleh ESP32, serta memastikan bahwa pesan-pesan tersebut sesuai dengan harapan.

   ```cpp
   Serial.println("Mengirim pesan MQTT: " + String(message));
   ```

6. **Lihat Pesan Kesalahan**: Periksa pesan kesalahan yang diberikan oleh broker MQTT atau perpustakaan MQTT yang Anda gunakan. Pesan kesalahan ini dapat memberikan petunjuk tentang apa yang salah.

7. **Periksa Konfigurasi**: Pastikan bahwa Anda memiliki konfigurasi yang benar untuk koneksi MQTT, termasuk alamat broker, port, nama pengguna, dan kata sandi.

8. **Monitor Koneksi WiFi**: Gunakan pesan debug untuk memantau status koneksi WiFi pada ESP32. Jika WiFi terputus, itu bisa menjadi penyebab masalah dalam komunikasi MQTT.

9. **Gunakan Tools Pemantauan MQTT**: Ada beberapa alat pemantauan MQTT yang dapat membantu Anda melihat aktivitas MQTT secara lebih rinci. Anda dapat menggunakan MQTT Explorer atau MQTT.fx, misalnya, untuk memonitor pesan-pesan yang dikirimkan ke dan dari broker.

10. **Periksa Firewall dan Port**: Pastikan bahwa firewall Anda tidak memblokir port yang digunakan oleh MQTT (biasanya 1883 atau 8883 untuk MQTT over TLS). Pastikan bahwa port tersebut terbuka untuk komunikasi.

11. **Uji di Jaringan yang Stabil**: Untuk mengisolasi masalah, uji ESP32 dan kode Anda di jaringan yang stabil dan pastikan semuanya berfungsi dengan baik sebelum mencoba di jaringan yang kurang stabil.

12. **Periksa Hardware dan Fisik**: Periksa fisik koneksi perangkat keras Anda, seperti kabel dan koneksi, untuk memastikan tidak ada masalah fisik yang memengaruhi komunikasi.

13. **Cari Forum atau Dokumentasi**: Cari forum atau dokumentasi terkait dengan perangkat keras ESP32, perpustakaan MQTT, atau broker MQTT yang Anda gunakan. Mungkin ada saran atau solusi yang telah dibagikan oleh pengguna lain.

14. **Perbarui Firmware dan Library**: Pastikan bahwa firmware ESP32 dan library MQTT Anda diperbarui ke versi terbaru untuk mengatasi masalah yang mungkin telah diperbaiki dalam pembaruan.

Dengan menggunakan langkah-langkah di atas, Anda dapat mengidentifikasi dan mengatasi masalah dalam komunikasi MQTT dengan ESP32. Penting untuk memiliki kesabaran dan metode pengujian yang sistematis saat melakukan debugging untuk mengidentifikasi akar penyebab masalah.

## Library MQTT yang direkomendasikan untuk digunakan dengan ESP32

Ada beberapa pustaka MQTT yang direkomendasikan untuk digunakan dengan ESP32. Di antaranya, ada dua pilihan populer:

1. **PubSubClient**: PubSubClient adalah pustaka MQTT yang populer untuk Arduino dan ESP8266/ESP32. Pustaka ini mudah digunakan dan cukup stabil. Banyak proyek IoT yang menggunakan PubSubClient dengan ESP32.

   Anda dapat menginstalnya melalui "Library Manager" di Arduino IDE. Setelah diinstal, Anda dapat dengan mudah menggunakannya untuk menghubungkan ESP32 dengan broker MQTT dan mengirim serta menerima pesan.

2. **AsyncMqttClient**: AsyncMqttClient adalah pustaka MQTT asinkron yang cocok untuk proyek-proyek ESP32 yang memerlukan penggunaan non-blocking. Pustaka ini memungkinkan Anda untuk menjalankan perintah MQTT tanpa menghentikan loop utama Anda, yang dapat berguna untuk menghindari kegagalan sistem akibat penundaan.

   Anda juga dapat menginstal AsyncMqttClient melalui "Library Manager" di Arduino IDE. Pustaka ini memiliki dokumentasi yang cukup baik dan banyak contoh yang tersedia.

Pilihan antara PubSubClient dan AsyncMqttClient tergantung pada kebutuhan proyek Anda. Jika Anda lebih suka pendekatan asinkron dan non-blocking, maka AsyncMqttClient bisa menjadi pilihan yang baik. Namun, jika Anda mencari pustaka yang lebih sederhana dan mudah digunakan, maka PubSubClient adalah pilihan yang bagus.

Selain kedua pustaka di atas, ada beberapa pustaka MQTT lainnya yang juga dapat digunakan dengan ESP32. Pastikan untuk membaca dokumentasi dan contoh penggunaan pustaka yang Anda pilih agar sesuai dengan kebutuhan proyek Anda.

## Implementasi autentikasi dengan username dan password saat terhubung ke broker MQTT pada ESP32

Untuk mengimplementasikan autentikasi dengan username dan password saat terhubung ke broker MQTT pada ESP32, Anda perlu mengonfigurasi ESP32 Anda untuk mengirim informasi autentikasi saat melakukan koneksi ke broker. Langkah-langkahnya adalah sebagai berikut:

1. **Inklusikan Library MQTT**: Pastikan Anda telah menginstal library MQTT yang sesuai di Arduino IDE, seperti PubSubClient atau AsyncMqttClient, dan termasukkannya di dalam kode Anda.

   ```cpp
   #include <PubSubClient.h>
   ```

   atau

   ```cpp
   #include <AsyncMqttClient.h>
   ```

2. **Tentukan Informasi Autentikasi**: Tetapkan nama pengguna (username) dan kata sandi (password) yang akan digunakan untuk autentikasi dengan broker MQTT. Anda perlu menyediakan informasi ini dalam kode Anda.

   ```cpp
   const char* mqtt_server = "alamat_broker_mqtt";
   const char* mqtt_user = "nama_pengguna";
   const char* mqtt_password = "kata_sandi";
   ```

3. **Inisialisasi Koneksi MQTT**: Inisialisasi objek koneksi MQTT dan tentukan informasi autentikasi saat menghubungkan ke broker.

   **Menggunakan PubSubClient**:

   ```cpp
   WiFiClient espClient;
   PubSubClient client(espClient);

   void setup() {
     // Inisialisasi koneksi WiFi seperti biasa

     // Inisialisasi koneksi MQTT dengan informasi autentikasi
     client.setServer(mqtt_server, 1883); // Ganti port sesuai dengan kebutuhan Anda
     client.setCallback(callback);
   }
   ```

   **Menggunakan AsyncMqttClient**:

   ```cpp
   AsyncMqttClient mqttClient;

   void setup() {
     // Inisialisasi koneksi WiFi seperti biasa

     // Inisialisasi koneksi MQTT dengan informasi autentikasi
     mqttClient.setServer(mqtt_server, 1883); // Ganti port sesuai dengan kebutuhan Anda
     mqttClient.setCredentials(mqtt_user, mqtt_password);
     mqttClient.onConnect(onMqttConnect);
     mqttClient.onDisconnect(onMqttDisconnect);
     mqttClient.onMessage(onMqttMessage);
   }
   ```

4. **Tentukan Callback Autentikasi**: Jika menggunakan AsyncMqttClient, Anda dapat menentukan callback untuk menghandle koneksi dan autentikasi. Callback `onMqttConnect` akan dipanggil saat koneksi berhasil, sedangkan `onMqttDisconnect` akan dipanggil saat koneksi terputus.

   ```cpp
   void onMqttConnect(bool sessionPresent) {
     Serial.println("Terhubung ke broker MQTT!");
   }

   void onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
     Serial.println("Terputus dari broker MQTT");
   }
   ```

5. **Koneksikan ke Broker MQTT**: Panggil fungsi untuk menghubungkan ESP32 ke broker MQTT dalam fungsi `setup()` atau di tempat lain yang sesuai dengan logika aplikasi Anda.

   **Menggunakan PubSubClient**:

   ```cpp
   if (client.connect("ESP32Client", mqtt_user, mqtt_password)) {
     Serial.println("Terhubung ke broker MQTT!");
     client.subscribe("topik/subs/esp32"); // Subscribe ke topik yang diperlukan
   } else {
     Serial.print("Gagal terhubung, rc=");
     Serial.print(client.state());
     Serial.println(" Coba lagi dalam 5 detik");
   }
   ```

   **Menggunakan AsyncMqttClient**:

   ```cpp
   mqttClient.connect();
   ```

Dengan langkah-langkah di atas, ESP32 Anda akan terhubung ke broker MQTT dengan autentikasi username dan password. Pastikan untuk mengganti nilai `mqtt_server`, `mqtt_user`, dan `mqtt_password` sesuai dengan konfigurasi broker MQTT Anda. Juga, sesuaikan kode sesuai dengan perpustakaan MQTT yang Anda gunakan (PubSubClient atau AsyncMqttClient).

## Implementasi Last Will and Testament (LWT) dalam MQTT, dan bagaimana mengonfiguraskannya di ESP32

Last Will and Testament (LWT) adalah fitur penting dalam protokol MQTT yang memungkinkan klien untuk mengirim pesan otomatis kepada broker MQTT jika klien terputus atau offline secara mendadak. Manfaat utama dari penggunaan LWT adalah:

1. **Indikator Status**: LWT memungkinkan broker dan klien untuk mengetahui status koneksi klien. Jika klien tiba-tiba terputus tanpa melakukan pemutusan koneksi yang benar, broker akan tahu bahwa klien tersebut tidak aktif.

2. **Notifikasi Terputusnya Klien**: Broker dapat menggunakan LWT untuk memberi tahu klien lain bahwa klien yang terputus sedang offline. Ini berguna jika klien tersebut memiliki peran khusus dalam jaringan atau jika tindakan perlu diambil ketika klien terputus.

3. **Penanganan Darurat**: Dalam beberapa kasus, jika klien adalah perangkat yang kritis, broker dapat menggunakan LWT untuk mengambil tindakan darurat, seperti mengirim pesan ke perangkat pengganti atau mengirim peringatan kepada administrator.

Konfigurasi LWT di ESP32 (atau klien MQTT lainnya) melibatkan beberapa langkah:

1. **Tentukan Pesan LWT**: Pertama, Anda perlu menentukan pesan yang akan dikirim oleh broker jika klien terputus. Pesan ini bisa berisi informasi tentang status klien atau tindakan yang perlu diambil.

   ```cpp
   const char* lwt_topic = "topik/lwt";
   const char* lwt_message = "Klien ESP32 terputus";
   ```

2. **Tentukan Kualitas Layanan (QoS) LWT**: Anda juga perlu menentukan tingkat QoS untuk pesan LWT. Ini bisa menjadi 0, 1, atau 2, tergantung pada tingkat keandalan yang Anda butuhkan.

   ```cpp
   const int lwt_qos = 1; // Misalnya, gunakan QoS 1
   ```

3. **Aktifkan LWT**: Aktifkan penggunaan LWT di ESP32 saat menghubungkan klien ke broker MQTT. Ini dilakukan dengan memanggil metode yang sesuai dari perpustakaan MQTT yang Anda gunakan.

   **Menggunakan PubSubClient**:

   ```cpp
   if (client.connect("ESP32Client", mqtt_user, mqtt_password, lwt_topic, lwt_qos, true, lwt_message)) {
     Serial.println("Terhubung ke broker MQTT!");
   } else {
     Serial.print("Gagal terhubung, rc=");
     Serial.print(client.state());
     Serial.println(" Coba lagi dalam 5 detik");
   }
   ```

   **Menggunakan AsyncMqttClient**:

   ```cpp
   mqttClient.setWill(lwt_topic, lwt_qos, false, lwt_message);
   mqttClient.connect();
   ```

Dalam kode di atas, `lwt_topic` adalah topik MQTT yang akan menerima pesan LWT jika klien terputus. `lwt_qos` adalah tingkat QoS yang akan digunakan untuk pesan LWT. `lwt_message` adalah pesan yang akan dikirimkan.

Dengan mengonfigurasi LWT, Anda dapat memastikan bahwa broker MQTT dapat mengetahui status koneksi klien dan mengambil tindakan yang sesuai jika klien terputus secara mendadak. Hal ini berguna terutama dalam aplikasi IoT yang memerlukan pemantauan dan respons terhadap klien yang tidak aktif.

### Hak cipta[^1]. Artikel ini berdasar ChatGpt & penulis tidak menjamin seluruh akurasi isinya

[^1]: [ChatGpt](https://chat.openai.com)
